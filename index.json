[{"content":"Ever since my teenage years, I\u0026rsquo;ve been captivated by the world of Linux and Open Source. This early interest has shaped my career path, focusing primarily on creating Software using the Java ecosystem. Today I focus on creating evolutionary software through the means of extreme programming.\n","date":null,"permalink":"/","section":"","summary":"Ever since my teenage years, I\u0026rsquo;ve been captivated by the world of Linux and Open Source.","title":""},{"content":"Explore strategies for reliable testing of time-dependent code, including techniques to mitigate flakiness in tests and enable precise time manipulation within your test suites.\nBy default, Java relies on the system clock to determine the current date and time. While in most cases this approach works fine when our system clock remains unchanged, it can quickly turn into a nightmare upon a simple faulty configuration change outside of your control.\nI have first-hand witnessed the consequences of an innocent OS upgrade silently altering the default time zone of a system. The impact was nothing short of disastrous, as all timestamps generated and stored by the application were suddenly off by a couple of hours. This post delves into the root cause of the issue, and as we will see, it presents a simple solution that at the same time enables us to write more robust tests and gain better control over the time-related aspects of our Java applications.\nThe time is now # The culprit of having our code depend on the system clock is the use of static java.time...now() methods such as:\nLocalDate.now() LocalDateTime.now() ZonedDateTime.now() OffsetDateTime.now() Instant.now() Examining the implementation of the ZonedDateTime.now() method in the JDK, we can see it delegates to another now method that takes a java.time.Clock instance as a parameter.\npublic final class ZonedDateTime implements Temporal, ChronoZonedDateTime\u0026lt;LocalDate\u0026gt;, Serializable { public static LocalTime now() { return now(Clock.systemDefaultZone()); } public static ZonedDateTime now(Clock clock) { Objects.requireNonNull(clock, \u0026#34;clock\u0026#34;); final Instant now = clock.instant(); // called once return ofInstant(now, clock.getZone()); } Within java.time.clock we can find a solution for ensuring our time related code is independent of the system\u0026rsquo;s time zone, while also facilitating easier testing. To further clarify this point, let\u0026rsquo;s refer to an excerpt from its documentation:\nUse of a Clock is optional. All key date-time classes also have a now() factory method that uses the system clock in the default time zone. The primary purpose of this abstraction is to allow alternate clocks to be plugged in as and when required. Applications use an object to obtain the current time rather than a static method. This can simplify testing.\nJava documentation\nThink of java.time.Clock as a physical wall clock that can be easily replaced with another clock within a different time zone. By passing along a java.time.Clock in all the java.time...now() methods, we decouple date-time generation from the system\u0026rsquo;s clock and simultaneously make it easier to test. As also stated in the documentation of the ZonedDateTime.now(Clock clock) method:\nUsing this method allows the use of an alternate clock for testing. The alternate clock may be introduced using dependency injection.\nJava documentation\nControlling the correct time zone # Passing a clock bound to a specific time zone frees us from relying solely on the system\u0026rsquo;s clock for date-time generation.\nZonedDateTime.now(Clock.system(ZoneId.of(\u0026#34;Europe/Brussels\u0026#34;))) By introducing a clock dependency, our production code becomes an area where accessing java.time.Clock is necessary. The same requirement extends to our tests, offering us significant benefits. In the next section, we will focus on the tests first and then proceed to examine our production code.\nFixating the clock # Having fine-grained control over date-time generation in our tests is indispensable for avoiding flaky tests. Java helps by allowing us to fixate the clock on a certain date-time within a specific time zone:\nClock.fixed(Instant.parse(\u0026#34;1985-02-25T23:00:00.00Z\u0026#34;), ZoneId.of(\u0026#34;Europe/Brussels\u0026#34;)); Let\u0026rsquo;s take the following piece of production code we want to test:\npublic class Order { private Status status; private LocalDateTime processDateTime; public Order markAsProcessed() { this.processDateTime = LocalDateTime.now(); this.status = PROCESSED; } } By adding a java.time.Clock as a dependency this becomes easily and accurately testsable:\npublic Order markAsProcessed(Clock clock) { this.processDateTime = LocalDateTime.now(clock); Which would result in the following test:\n// given var order = OrderMother.newOrder(); // when var clock = Clock.fixed(Instant.parse(\u0026#34;1985-02-25T23:00:00.00Z\u0026#34;), ZoneId.of(\u0026#34;Europe/Brussels\u0026#34;); order.markAsProcessed(clock); // then assertThat(order.processDateTime()) .isEqualTo(LocalDateTime.parse(\u0026#34;1985-02-26T00:00:00\u0026#34;)); Notice how in the assertion the day has moved on by one hour and one day, because the date-time is generated in a +1 time zone.\nAlternative solutions # Truncating time for more precision # There are alternative solutions available for testing date-time generation if you prefer not to rely on java.time.Clock. However, it\u0026rsquo;s important to note that relying solely on the system\u0026rsquo;s default clock carries its own risks.\nThe problem with asserting the generated date-time is that even a small amount of time between generating the date-time and asserting it can lead to faulty assertions. Consequently, this test example without the clock will likely be unreliable:\n// given var order = OrderMother.newOrder(); // when order.markAsProcessed(); // then assertThat(order.processDateTime()) .isEqualTo(LocalDateTime.now()); This test is prone to flakiness and will probably fail consistently due to the time that elapses between the markAsProcessed method\u0026rsquo;s LocalDateTime.now() call and the actual assertion. To mitigate this, you can truncate the generated date-time to seconds or milliseconds and perform the same truncation in the assertion. While this approach reduces flakiness, it doesn\u0026rsquo;t guarantee 100% accuracy. But in most cases that trade-off is acceptable. Here\u0026rsquo;s an example of truncating to seconds in your production code:\nInstant.now().truncatedTo(ChronoUnit.SECONDS) And this can be tested like so:\n// given var order = OrderMother.newOrder(); // when order.markAsProcessed(); // then assertThat(order.processDateTime()) .isEqualTo(LocalDateTime.now().truncatedTo(ChronoUnit.SECONDS)); Wondering what this OrderMother is, check out my previous article on mothers\nAssert generated time is close enough to now # A second alternative is to utilize AssertJ\u0026rsquo;s .closeTo assertion methods, which provides a convenient way to assert values within a specified range. Here are a couple of examples to illustrate this:\nvar localDateTime = LocalDateTime.now(Clock.systemUTC()); assertThat(localDateTime) .isCloseToUtcNow(within(1, ChronoUnit.SECONDS)); var instant = Instant.parse(\u0026#34;2000-01-01T00:00:00.00Z\u0026#34;) assertThat(instant) .isCloseTo(\u0026#34;1999-12-31T23:59:59.99Z\u0026#34;, within(10, ChronoUnit.MILLIS)) Clock as a spring bean # Going forward with the clock. Whenever we require access to the current date-time, it is necessary to have access to the clock. However, passing the clock object throughout our code can become cumbersome. Fortunately, most modern applications make use of an IoC (Inversion of Control) Container, which alleviates this burden. As a result, we will expose the Clock as an object eligible for inversion of control or, in Spring terminology, convert it into a bean.\n@Configuration class ClockConfiguration { @Bean Clock clock(@Value(\u0026#34;${app.time.zone-id}\u0026#34;) String zoneId){ return Clock.system(ZoneId.of(zoneId)); } } Depending on our needs, we have the option to either hard-code the active timezone or, as demonstrated in the example above, make it configurable. In either case, this approach allows us to conveniently inject the clock whenever necessary, as illustrated in the example below.\n@Service public class OrderService { private final Clock clock; private final OrderRepository orderRepository; public OrderService(OrderRepository orderRepository, Clock clock) { this.clock = clock; this.orderRepository = orderRepository; } public void processOrder(OrderId orderId) { var order = orderRepository.findById(orderId); order.markAsProcessed(clock); // etc .. } } Particularly within testing scenarios, having a clock eligible for inversion of control becomes critical. As it empowers us to precisely control and manipulate time-related behavior in our tests. Just like in our unit tests, let\u0026rsquo;s start by exposing a fixated clock.\n@Configuration public class TestClockConfiguration { @Bean @Primary Clock fixedClock() { return Clock.fixed(Instant.parse(\u0026#34;1985-02-25T23:00:00.00Z\u0026#34;), ZoneId.of(\u0026#34;Europe/Brussels\u0026#34;); } } To ensure consistent time behavior across all tests within a Spring context, we can include the above configuration in our test package. This will, due to the use of @Primary override the clock defined in our production code with a fixed clock. Now we can assert the order to be marked as processed at the fixed date-time.\nWhat if we require precise control over the clock at a per-test level within a single Spring context, without the need to create a new context for each case where a different clock is desired? Or maybe we want to play with our current date-time and actually move time forward or maybe even rewind it? The next section will cover these use-cases.\nMutable clock # The default java.time.Clock implementation is immutable in the sense that you can not change it\u0026rsquo;s current date-time or timezone. By incorporating a mutable clock that can manipulate time or be set to a specific date-time within our tests, we can avoid the need for multiple Spring contexts.\npublic class MutableTestClock extends Clock { private Instant instant; private final ZoneId zone; public MutableClock(Instant instant, ZoneId zone) { this.instant = instant; this.zone = zone; } @Override public ZoneId getZone() { return zone; } @Override public Clock withZone(ZoneId zone) { return new MutableTestClock(instant, zone); } @Override public Instant instant() { return instant; } public void fastForward(TemporalAmount temporalAmount) { set(instant().plus(temporalAmount)); } public void rewind(TemporalAmount temporalAmount) { set(instant().minus(temporalAmount)); } public void set(Instant instant) { this.instant = instant; } public static MutableClock fixed(Instant instant, ZoneId zone) { return new MutableTestClock(instant, zone); } public static MutableClock fixed(OffsetDateTime offsetDateTime) { return fixed(offsetDateTime.toInstant(), offsetDateTime.getOffset()); } } Exposing the mutable clock:\n@Configuration public class TestClockConfiguration { @Bean @Primary Clock testClock(@Value(\u0026#34;${app.time.zone-id}\u0026#34;) String zoneId) { return new MutableClock(Instant.parse(\u0026#34;1985-02-25T23:00:00.00Z\u0026#34;), ZoneId.of(zoneId)); } } Now, let\u0026rsquo;s put this knowledge to good use by writing a test for the following piece of production code:\n@Component public class OrderProcessor { private final Clock clock; private final LocalTime startOfWorkingDay = LocalTime.of(8, 0); private final LocalTime endOfWorkingDay = LocalTime.of(22, 0); public OrderProcessor(Clock clock) { this.clock = clock; } public void processOrder(Order order) { if (isWithinWorkingHours()) { processNow(order); } else { processLater(order); } } public boolean isWithinWorkingHours() { LocalTime now = LocalTime.now(clock) return !now.isBefore(startOfWorkingDay) \u0026amp;\u0026amp; !time.isAfter(endOfWorkingDay); } } public class OrderProcessingFeatureTest { private final MutableClock mutableClock; public OrderProcessingFeatureTest(Clock clock) { this.mutableClock = (MutableClock)clock; } @Test void shouldProcessOrderWithinWorkingHours() { // given mutableClock.set(Instant.parse(\u0026#34;2023-02-25T13:00:00.00Z\u0026#34;)) // when var resultActions = mockMvc.perform(post(\u0026#34;/orders/ORD567890\u0026#34;) .contentType(MediaType.APPLICATION_JSON) .content(toJson(OrderMother.defaultOrder())); // then resultActions.andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.status\u0026#34;).value(\u0026#34;PROCESSED\u0026#34;)); } @Test void shouldProcessOrderLaterWhenReceivedOutsideOfWorkingHours() { // given mutableClock.set(Instant.parse(\u0026#34;2023-02-25T23:00:00.00Z\u0026#34;)) // when var resultActions = mockMvc.perform(post(\u0026#34;/orders/ORD4785669\u0026#34;) .contentType(MediaType.APPLICATION_JSON) .content(toJson(OrderMother.defaultOrder())); // then resultActions.andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.status\u0026#34;).value(\u0026#34;PROCESS_LATER\u0026#34;)); } } In conclusion, leveraging the java.time.Clock class and its capability to decouple date-time generation from the system clock empowers us to write more effective tests for time-dependent code. This approach not only grants us greater control over time-related aspects but also acts as a safeguard against issues arising from system clock changes, as I have personally encountered.\n","date":"9 July 2023","permalink":"/posts/how-to-effectively-test-time-dependent-code/","section":"Jonas on Software","summary":"\u003cp\u003eExplore strategies for reliable testing of time-dependent code, including techniques to mitigate flakiness in tests and enable precise time manipulation within your test suites.\u003c/p\u003e","title":"How to Effectively Test Time-Dependent Code: Unit and Spring-Based Strategies"},{"content":"","date":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"java"},{"content":" ⛵ Navigating the realm of Java, Software Architecture and Testing with in-depth explorations and practical insights. # ","date":null,"permalink":"/posts/","section":"Jonas on Software","summary":"⛵ Navigating the realm of Java, Software Architecture and Testing with in-depth explorations and practical insights.","title":"Jonas on Software"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/tags/testing/","section":"Tags","summary":"","title":"testing"},{"content":"Discover how the Object Mother concept empowers developers to effortlessly generate intricate test objects, enhancing code readability, maintainability, and overall testing efficiency.\nThe creational problem # A good structured test exists out of three parts commonly known as: Given When Then or Arrange Act Assert.\nWithin the Given part you declare a set of objects that will drive your test. Initially the creational logic is simple, as the objects may have fewer fields or lack coherence. However, inevitably over time, the set of objects grows as their intricacy, they become more complex and time-consuming to construct.\nVarious solutions exist to address those issues, such as Test Data Factories, Data Fakers, Test Data Generators or Fixture Builders etc .. In the end they all share a common goal: simplifying object creation while ensuring reusability. Martin Fowler has even coined a term for this concept, known as Object Mother.\nLet\u0026rsquo;s delve deeper into the problem by examining a concrete example. While this example may not be overly complex or entirely realistic, the purpose of this article is to work with practical scenarios without getting bogged down in the intricacies of object creation.\nAddress billingAddress = new Address.Builder() .streetAddress(\u0026#34;123 Main St\u0026#34;) .city(\u0026#34;Anytown\u0026#34;) .state(\u0026#34;CA\u0026#34;) .zipCode(\u0026#34;12345\u0026#34;) .country(Country.US) .build(); Address shippingAddress = new Address.Builder() .streetAddress(\u0026#34;456 Oak Ave\u0026#34;) .city(\u0026#34;Othertown\u0026#34;) .state(\u0026#34;CA\u0026#34;) .zipCode(\u0026#34;67890\u0026#34;) .country(Country.US) .build(); List\u0026lt;InvoiceItem\u0026gt; items = new ArrayList\u0026lt;\u0026gt;(); items.add(new InvoiceItem(\u0026#34;Product A\u0026#34;, Amount.EUR(100.00), Tax.vatPercentage(21))); items.add(new InvoiceItem(\u0026#34;Product B\u0026#34;, Amount.EUR(100.00), Tax.vatPercentage(21))); Customer customer = new Customer.Builder() .name(\u0026#34;John Doe\u0026#34;) .email(\u0026#34;john.doe@example.com\u0026#34;) .phoneNumber(\u0026#34;555-123-4567\u0026#34;) .build(); Invoice invoice = new Invoice( new InvoiceNumber(\u0026#34;001\u0026#34;), customer, billingAddressm, shippingAddress, LocalDate.now(), items); Amount amount = invoice.getVatAmount(); assertThat(amount).isEqualTo(Amount.EUR(42)) In the case of the aforementioned test, an Invoice object is needed, which, in turn, depends on several other objects. However, it is noteworthy that, for this specific test, only the invoice items hold significance. They play a vital role in asserting and calculating the VAT amount.\nTest Data - Factory, Generator, Builder, Fixtures \u0026hellip; # There are numerous patterns available to create the required objects for your tests. A very common approach to simplify the creational logic while at the same time having some kind of of code reuse in place is to create static factory methods returning the required objects.\nInvoiceTestDataFactory.invoice(); While this approach may initially appear to solve the creational issue, it tends to scale poorly As Martin Fowler highlights:\nObject Mothers do have their faults. In particular there\u0026rsquo;s a heavy coupling in that many tests will depend on the exact data in the mothers.\nI\u0026rsquo;ve observed several solutions to address this issue, including;\ncreating specific static factory methods adding parameters to differentiate the creational logic. InvoiceTestDataFactory.invoiceWithoutShippingAddress(); InvoiceTestDataFactory.invoiceWithoutBillingAddressAndThreeItems(); InvoiceTestDataFactory.invoice(new InvoiceNumber(\u0026#34;001\u0026#34;), \u0026#34;john@doe,com\u0026#34;); InvoiceTestDataFactory.invoice( new InvoiceItem(\u0026#34;Product A\u0026#34;, Amount.EUR(100.00), Tax.vatPercentage(21)), new InvoiceItem(\u0026#34;Product B\u0026#34;, Amount.EUR(100.00), Tax.vatPercentage(21))); While these solutions may initially appear to solve the coupling issue, they often result in tight coupling between specific factory methods and the requirements of individual tests, limiting their reusability.\nOne introduces different factory methods or several sets of parameters because there are tests that require different permutations of the same objects under test.\nImagine you have an object with 5 primitive fields and 5 custom-typed fields. The question arises: how many permutations of factory methods or parameter sets would be required to cover all your test cases? Introducing static factory methods or parameters might make the code challenging to maintain and may not facilitate effective communication within the Given part of your tests. Ultimately, pursuing this path leads to test data factories that are difficult to maintain and confusing to use.\nSo, how can we simplify the technical creational logic while simultaneously highlighting its essential aspects?\nEmphasize what matters and hide the irrelevant parts # By combining the Object Mother concept with pre-filled builders it becomes possible to hide away all unnecessary complexity while at the same time emphasizing what matters for your test-case.\nLet\u0026rsquo;s put this into practice using the previous example:\nInvoice invoice = InvoiceMother.invoice() .withInvoiceItems( new InvoiceItem(\u0026#34;Product A\u0026#34;, Amount.EUR(100.00), Tax.vatPercentage(21)), new InvoiceItem(\u0026#34;Product B\u0026#34;, Amount.EUR(100.00), Tax.vatPercentage(21))) .build(); Amount amount = invoice.getVatAmount(); assertThat(amount).isEqualTo(Amount.EUR(42)) By utilizing the approach mentioned above, the unnecessary clutter is eliminated, allowing the focus to be solely on what is essential for the test. In this particular case, it becomes evident that having two invoice items priced at EUR 100 each, with a 21% tax applied to each item, results in EUR 42 of taxes\nWe are still using some kind of static factory method yet it does not immediately return our Invoice rather it returns a InvoiceMother$InvoiceBuilder. I like to make the builder part of the Mother class as to reduce the chance to confuse it with production code InvoiceBuilders.\npublic class InvoiceMother { private InvoiceMother() { } public static Builder invoice() { return new Builder(); } public static class Builder { InvoiceNumber invoiceNumber = new InvoiceNumber(\u0026#34;001\u0026#34;); Customer customer = CustomerMother.customer().build(); Address billingAddress = AddressMother.address().build(); Address shippingAddress = AddressMother.address().build(); LocalDate creationDate = LocalDate.now(); List\u0026lt;InvoiceItem\u0026gt; items = List.of(InvoiceItemMother.item().build()); public Builder withItems(List\u0026lt;InvoiceItem\u0026gt; items) { this.items = items; return this; } // other setters are left out for brevity public Invoice build() { return new Invoice( invoiceNumber, customer, billingAddressm, shippingAddress, creationDate, items); } } } It\u0026rsquo;s important to note that the concept discussed here is not about the suffix \u0026lsquo;Mother.\u0026rsquo; If you find the suffix unfavorable, feel free to use any other suffix that better suits your needs, such as InvoiceTestDataFactory, InvoiceFixture, InvoiceTestData, and so on.\nWhat is important:\nLet your factory methods return Builders not the object under creation. Limit your static factory methods to the absolute minimum. Rather override a field using the Builder than to introduce a new static factory method. Use a pre-filled Builder What can flex:\nLet the defaults for custom complex objects depend on other Mothers The Mother suffix Making the Builder part of your Mother class But what if your test requires a specific field in one of the nested custom objects to be in a particular state? For instance, you may need the shipping address\u0026rsquo;s country to be set as \u0026lsquo;US,\u0026rsquo; while the other field values are irrelevant for your test. With the current setup, you would have to pass in another mother object and build it fully changing only that field that matter for your test.\nInvoiceMother.invoice() .withShippingAddress(AddressMother.addres() .withCountry(Country.US) .build()) .build(); Although this approach works, we can further improve it by utilizing a java.util.function.Consumer with the AddressMother.Builder:\nInvoiceMother.invoice() .withShippingAddress(b -\u0026gt; b.withCountry(Country.US)) .build(); In this case, the builder method would look like this:\npublic Builder withShippingAddress(Consumer\u0026lt;AddressMother.Builder\u0026gt; addressConsumer) { Address.Builder builder = AddressMother.address(); addressConsumer.accept(builder) this.shippingAddress = builder.build(); return this; } These enhancements aim to improve the readability and clarity of the code example while retaining the original meaning and intent.\nTakeaways # In conclusion, the Object Mother concept offers developers a powerful approach to effortlessly generate intricate test objects. By combining the concept with pre-filled builders, developers can effectively simplify the technical creational logic while emphasizing the essential aspects of their test cases.\nBy embracing the Object Mother concept and its principles, developers can achieve enhanced code readability, maintainability, and overall testing efficiency in their software projects. This becomes particularly crucial in complex projects, as tests serve not only to verify code correctness and guide design but also to serve as documentation and prevention of regression. When regression does occur, it is vital for both your future self and colleagues to clearly understand what is being tested.\n","date":"5 June 2023","permalink":"/posts/object-mother/","section":"Jonas on Software","summary":"\u003cp\u003eDiscover how the Object Mother concept empowers developers to effortlessly generate intricate test objects,\nenhancing code readability, maintainability, and overall testing efficiency.\u003c/p\u003e","title":"Mastering the Object Mother"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/search/","section":"","summary":"search","title":"Search"}]