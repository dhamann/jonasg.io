[{"content":"Ever since my teenage years, I\u0026rsquo;ve been captivated by the world of Linux and Open Source. This early interest has shaped my career path, focusing primarily on creating Software using the Java ecosystem. Today I focus on creating evolutionary software through the means of extreme programming.\n","date":null,"permalink":"/","section":"","summary":"Ever since my teenage years, I\u0026rsquo;ve been captivated by the world of Linux and Open Source.","title":""},{"content":"","date":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"java"},{"content":" ⛵ Navigating the realm of Java, Software Architecture and Testing with in-depth explorations and practical insights. # ","date":null,"permalink":"/posts/","section":"Jonas on Software","summary":"⛵ Navigating the realm of Java, Software Architecture and Testing with in-depth explorations and practical insights.","title":"Jonas on Software"},{"content":"Discover how the Object Mother concept empowers developers to effortlessly generate intricate test objects, enhancing code readability, maintainability, and overall testing efficiency.\nThe creational problem # A good structured test exists out of three parts commonly known as: Given When Then or Arrange Act Assert.\nWithin the Given part you declare a set of objects that will drive your test. Initially the creational logic is simple, as the objects may have fewer fields or lack coherence. However, inevitably over time, the set of objects grows as their intricacy, they become more complex and time-consuming to construct.\nVarious solutions exist to address this underlying issue, such as Test Data Factories, Data Fakers, Test Data Generators or Fixture Builders etc .. In the end they all share a common goal: simplifying object creation while ensuring reusability. Martin Fowler has even coined a term for this concept, known as Object Mother.\nLet\u0026rsquo;s delve deeper into the problem by examining a concrete example. While this example may not be overly complex or entirely realistic, the purpose of this article is to work with practical scenarios without getting bogged down in the intricacies of object creation.\nAddress billingAddress = new Address.Builder() .streetAddress(\u0026#34;123 Main St\u0026#34;) .city(\u0026#34;Anytown\u0026#34;) .state(\u0026#34;CA\u0026#34;) .zipCode(\u0026#34;12345\u0026#34;) .country(Country.US) .build(); Address shippingAddress = new Address.Builder() .streetAddress(\u0026#34;456 Oak Ave\u0026#34;) .city(\u0026#34;Othertown\u0026#34;) .state(\u0026#34;CA\u0026#34;) .zipCode(\u0026#34;67890\u0026#34;) .country(Country.US) .build(); List\u0026lt;InvoiceItem\u0026gt; items = new ArrayList\u0026lt;\u0026gt;(); items.add(new InvoiceItem(\u0026#34;Product A\u0026#34;, Amount.EUR(100.00), Tax.vatPercentage(21))); items.add(new InvoiceItem(\u0026#34;Product B\u0026#34;, Amount.EUR(100.00), Tax.vatPercentage(21))); Customer customer = new Customer.Builder() .name(\u0026#34;John Doe\u0026#34;) .email(\u0026#34;john.doe@example.com\u0026#34;) .phoneNumber(\u0026#34;555-123-4567\u0026#34;) .build(); Invoice invoice = new Invoice( new InvoiceNumber(\u0026#34;001\u0026#34;), customer, billingAddressm, shippingAddress, LocalDate.now(), items); Amount amount = invoice.getVatAmount(); assertThat(amount).isEqualTo(Amount.EUR(42)) In the case of the aforementioned test, an Invoice object is needed, which, in turn, depends on several other objects. However, it is noteworthy that, for this specific test, only the invoice items hold significance. They play a vital role in asserting and calculating the VAT amount.\nTest Data - Factory, Generator, Builder, Fixtures \u0026hellip; # There are numerous patterns available to create the required objects for your tests. A very common approach to simplify the creational logic while at the same time having some kind of of code reuse in place is to create static factory methods returning the required objects.\nInvoiceTestDataFactory.invoice(); While this approach may initially appear to solve the creational issue, it tends to scale poorly As Martin Fowler highlights:\nObject Mothers do have their faults. In particular there\u0026rsquo;s a heavy coupling in that many tests will depend on the exact data in the mothers.\nI\u0026rsquo;ve observed several implemented solutions used to address this issue, including;\ncreating specific static factory methods adding parameters to differentiate the creational logic. InvoiceTestDataFactory.invoiceWithoutShippingAddress(); InvoiceTestDataFactory.invoiceWithoutBillingAddressAndThreeItems(); InvoiceTestDataFactory.invoice(new InvoiceNumber(\u0026#34;001\u0026#34;), \u0026#34;john@doe,com\u0026#34;); InvoiceTestDataFactory.invoice( new InvoiceItem(\u0026#34;Product A\u0026#34;, Amount.EUR(100.00), Tax.vatPercentage(21)), new InvoiceItem(\u0026#34;Product B\u0026#34;, Amount.EUR(100.00), Tax.vatPercentage(21))); While solutions like the ones above at first glance appear to solve the coupling issue it actually makes it worse while at the same time introducing a whole other set of challenges.\nOne introduces different factory methods or several sets of parameters because there are tests that require different permutations of the same objects under test.\nImagine you have an object with 5 primitive fields and 5 custom-typed fields. The question arises: how many permutations of factory methods or parameter sets would be required to cover all your test cases? Introducing static factory methods or parameters might make the code challenging to maintain and may not facilitate effective communication within the Given part of your tests. Ultimately, pursuing this path leads to test data factories that are difficult to maintain and confusing to use.\nSo, how can we simplify the technical creational logic while simultaneously highlighting its essential aspects?\nEmphasize what matters and hide the irrelevant parts # By combining the Object Mother concept with pre-filled builders it becomes possible to hide away all unnecessary complexity while at the same time emphasizing what matters for your test-case.\nLet\u0026rsquo;s put this into practice using the previous example:\nInvoice invoice = InvoiceMother.invoice() .withInvoiceItems( new InvoiceItem(\u0026#34;Product A\u0026#34;, Amount.EUR(100.00), Tax.vatPercentage(21)), new InvoiceItem(\u0026#34;Product B\u0026#34;, Amount.EUR(100.00), Tax.vatPercentage(21))) .build(); Amount amount = invoice.getVatAmount(); assertThat(amount).isEqualTo(Amount.EUR(42)) By utilizing the approach mentioned above, the unnecessary clutter is eliminated, allowing the focus to be solely on what is essential for the test. In this particular case, it becomes evident that having two invoice items priced at EUR 100 each, with a 21% tax applied to each item, results in EUR 42 of taxes\nWe are still using some kind of static factory method yet it does not immediately return our Invoice rather it returns a InvoiceMother$InvoiceBuilder. I like to make the builder part of the Mother class as to reduce the chance to confuse it with production code InvoiceBuilders.\npublic class InvoiceMother { private InvoiceMother() { } public static Builder invoice() { return new Builder(); } public static class Builder { InvoiceNumber invoiceNumber = new InvoiceNumber(\u0026#34;001\u0026#34;); Customer customer = CustomerMother.customer().build(); Address billingAddress = AddressMother.address().build(); Address shippingAddress = AddressMother.address().build(); LocalDate creationDate = LocalDate.now(); List\u0026lt;InvoiceItem\u0026gt; items = List.of(InvoiceItemMother.item().build()); public Builder withItems(List\u0026lt;InvoiceItem\u0026gt; items) { this.items = items; return this; } // other setters are left out for brevity public Invoice build() { return new Invoice( invoiceNumber, customer, billingAddressm, shippingAddress, creationDate, items); } } } It\u0026rsquo;s important to note that the concept discussed here is not about the suffix \u0026lsquo;Mother.\u0026rsquo; If you find the suffix unfavorable, feel free to use any other suffix that better suits your needs, such as InvoiceTestDataFactory, InvoiceFixture, InvoiceTestData, and so on.\nWhat is important:\nLimit your static factory methods to the absolute minimum Rather override a field using the Builder than to introduce a new static factory method Work on a pre-filled Builder What can flex:\nLet the defaults for custom complex objects depend on other Mothers The Mother suffix Making the Builder part of your Mother class But what if your test requires a specific field in one of the nested custom objects to be in a particular state? For instance, you may need the shipping address\u0026rsquo;s country to be set as \u0026lsquo;US,\u0026rsquo; while the other field values are irrelevant for your test. With the current setup, you would have to pass in another mother object and build it fully changing only that field that matter for your test.\nInvoiceMother.invoice() .withShippingAddress(AddressMother.addres() .withCountry(Country.US) .build()) .build(); Although this approach works, we can further improve it by utilizing a java.util.function.Consumer with the AddressMother.Builder:\nInvoiceMother.invoice() .withShippingAddress(a -\u0026gt; a.withCountry(Country.US)) .build(); In this case, the builder method would look like this:\npublic Builder withShippingAddress(Consumer\u0026lt;AddressMother.Builder\u0026gt; addressConsumer) { Address.Builder builder = AddressMother.address(); addressConsumer.accept(builder) this.shippingAddress = builder.build(); return this; } These enhancements aim to improve the readability and clarity of the code example while retaining the original meaning and intent.\nTakeaways # In conclusion, the Object Mother concept offers developers a powerful approach to effortlessly generate intricate test objects. By combining the concept with pre-filled builders, developers can effectively simplify the technical creational logic while emphasizing the essential aspects of their test cases.\nBy embracing the Object Mother concept and its principles, developers can achieve enhanced code readability, maintainability, and overall testing efficiency in their software projects. This becomes particularly crucial in complex projects, as tests serve not only to verify code correctness and guide design but also to serve as documentation and prevention of regression. When regression does occur, it is vital for both your future self and colleagues to clearly understand what is being tested.\n","date":"5 June 2023","permalink":"/posts/object-mother/","section":"Jonas on Software","summary":"\u003cp\u003eDiscover how the Object Mother concept empowers developers to effortlessly generate intricate test objects,\nenhancing code readability, maintainability, and overall testing efficiency.\u003c/p\u003e","title":"Mastering the Object Mother"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/tags/testing/","section":"Tags","summary":"","title":"testing"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/search/","section":"","summary":"search","title":"Search"}]